#!/usr/bin/perl
############################################################################################
#                       (C) Copyright 2018 Acxiom LLC
#                               All Rights Reserved.
############################################################################################
#
# Script: join-hero
# Author: Caleb Hankins - chanki
# Date:   2018-12-10
#
# Purpose: Oracle DDL parser for scraping PK/FK/Unique Key metadata describing table joins
#
############################################################################################
# MODIFICATION HISTORY
##----------------------------------------------------------------------------------------
# DATE        PROGRAMMER                   DESCRIPTION
##----------------------------------------------------------------------------------------
# 2018-12-10  Caleb Hankins - chanki       Initial Copy
############################################################################################

use strict;
use warnings;
use IO::Handle;                                 # Supply object methods for I/O handles
use Pod::Usage;                                 # Print a usage message from embedded pod documentation
use Getopt::Long;                               # Extended processing of command line options
use Cwd qw( cwd abs_path );                     # Get current working directory and absolute file paths
use File::Basename;                             # Parse file paths into directory, filename and suffix
use File::Glob ':glob';                         # Perl extension for BSD glob routine
use lib dirname(dirname(__FILE__)) . '/lib';    # Use local libraries if we have them
use JoinHero;
no if $] >= 5.017011, warnings => 'experimental::smartmatch';    # Suppress smartmatch warnings

# Turn on auto-flush / hot pipes
STDOUT->autoflush(1);
STDERR->autoflush(1);

my $inputFilepath                     = '';
my $updateExisting                    = '';
my $deleteExisting                    = '';
my $types                             = '';
my $marts                             = '';
my @supportedTypes                    = ('SAMPLE');
my @supportedMarts                    = ('SAMPLE');
my $outputFilepath                    = '';
my $martTableJoinTableName            = 'MART_TABLE_JOIN';
my $martTableJoinCardinalityTableName = 'MART_TABLE_JOIN_CARDINALITY';
my $commitThreshold                   = 1000;
my $coreFlg                           = 'Y';
my $testMode                          = '';
my $verbose                           = '';

my $rc = GetOptions(
  'i|file|inputFilepath=s'              => \$inputFilepath,
  'o|out|outputFilepath=s'              => \$outputFilepath,
  'types=s'                             => \$types,
  'marts=s'                             => \$marts,
  'u|updateExisting'                    => \$updateExisting,
  'd|deleteExisting'                    => \$deleteExisting,
  'martTableJoinTableName=s'            => \$martTableJoinTableName,
  'martTableJoinCardinalityTableName=s' => \$martTableJoinCardinalityTableName,
  'commitThreshold=i'                   => \$commitThreshold,
  'coreFlg=s'                           => \$coreFlg,

  't|testMode' => \$testMode,
  'v|verbose'  => \$verbose,

  #pod2usage variables
  'help' => sub { pod2usage(0); },
  'man'  => sub { pod2usage(-exitstatus => 0, -verbose => 2); }
);

sanityCheckOptions();

# Load up DDL source file
my $inputFileContents = JoinHero::openAndLoadFile($inputFilepath);

# Parse DDL Source file into usable components
my ($pk, $fk) = JoinHero::getKeyComponents($inputFileContents, \@supportedMarts);

# Use our component list to construct some oracle merge statements
my $outputFileContents = JoinHero::getOutputSQL(
                                               {
                                                pkComponents                      => $pk,
                                                fkComponents                      => $fk,
                                                commitThreshold                   => $commitThreshold,
                                                deleteExisting                    => $deleteExisting,
                                                updateExisting                    => $updateExisting,
                                                martTableJoinTableName            => $martTableJoinTableName,
                                                martTableJoinCardinalityTableName => $martTableJoinCardinalityTableName,
                                                coreFlg                           => $coreFlg,
                                                supportedTypes                    => \@supportedTypes,
                                                supportedMarts                    => \@supportedMarts
                                               }
);

# Create file containing SQL statements that can be used to update join metadata
JoinHero::createExportFile($outputFileContents, $outputFilepath);

exit;

##---------------------------------------------------------------------------
# Give script options the ol' sanity check
sub sanityCheckOptions {
  my $subName  = (caller(0))[3];
  my $errorCnt = 0;

  if ($types) { @supportedTypes = split(',', $types); }
  if ($marts) { @supportedMarts = split(',', $marts); }
  if ('CMP'    ~~ @supportedMarts) { push(@supportedMarts, 'CMP_DM'); }    # Add the long name if short is present
  if ('CMP_DM' ~~ @supportedMarts) { push(@supportedMarts, 'CMP'); }       # Add the short name if long is present
  @supportedMarts = JoinHero::getUniqArray(@supportedMarts);

  $JoinHero::logger->info("$subName Supported target application types: [" . join(',', @supportedTypes) . "]\n");
  $JoinHero::logger->info("$subName Supported mart prefixes: [" . join(',', @supportedMarts) . "]\n");
  $JoinHero::logger->info("$subName Processing '$inputFilepath', wish me luck!\n");

  $inputFilepath = bsd_glob($inputFilepath);
  JoinHero::checkRequiredParm($inputFilepath, 'inputFilepath');
  $outputFilepath = bsd_glob($outputFilepath);
  JoinHero::checkRequiredParm($outputFilepath, 'outputFilepath');

  # Set package level variables
  $JoinHero::verbose = $verbose;

  # Check for errors before starting processing
  if ($JoinHero::logger->get_count("ERROR") > 0) {

    # Print informational message to standard error
    $JoinHero::logger->error(  "$subName There were ["
                             . $JoinHero::logger->get_count("ERROR")
                             . "] error messages detected while sanity checking options. Script is halting.");

    # Exit with a non-zero code and print usage
    pod2usage(10);
  } ## end if ($JoinHero::logger->...)

  return;
} ## end sub sanityCheckOptions
##---------------------------------------------------------------------------

##---------------------------------------------------------------------------
# Podusage

__END__

=head1 AUTHOR

Caleb Hankins - chanki

=head1 NAME

join-hero

=head1 SYNOPSIS

 Oracle DDL parser for scraping PK/FK/Unique Key metadata describing table joins

 Options:
  'i|file|inputFilepath=s'              DDL File input file with key info [required]
  'o|out|outputFilepath=s'              Output filepath for metadata [optional]
  'types=s'                             Application type [optional]
  'marts=s'                             Data mart prefix [optional]
  'u|updateExisting'                    Update existing metadata [optional]
  'd|deleteExisting'                    Delete existing metadata [optional]
  'martTableJoinTableName=s'            Override for MTJ table name [optional]
  'martTableJoinCardinalityTableName=s' Override for MTJ Cardinality table nam[optional]
  'commitThreshold=i'                   Statements to execute before issuing a commit [optional]
  'coreFlg=s'                           Set metadata as 'Core' [optional]

  't|testMode'
  'v|verbose'
  
  --help  Print brief help information.
  --man   Read the manual, includes examples.

=head1 EXAMPLES

# Generate a full_insert.sql file containing SQL commands to update metadata
perl join-hero -i './Export/model.ddl' -o './update_sql/full_insert.sql' -v > ./logs/full_insert.log

# Override target tables to research tables, include delete flag for cleanup
perl join-hero -i '.\ddl\model.ddl' -o './update_sql/full_update.sql' > ./logs/full_update.log --martTableJoinTableName 'TEMP_MERGED_MTJ' --martTableJoinCardinalityTableName 'TEMP_MERGED_MTJ_CARD' -d
  
=cut
##---------------------------------------------------------------------------
