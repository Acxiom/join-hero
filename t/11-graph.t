#!/usr/bin/perl -w
use strict;
use warnings FATAL => 'all';
use Test::More;
use English qw(-no_match_vars);
no if $] >= 5.017011, warnings => 'experimental::smartmatch';    # Suppress smartmatch warnings

use JoinHero;

# $JoinHero::verbose = 1;    # Uncomment this and run tests with --verbose to ease debugging

# Skip these tests if we don't have the graph library
eval { require Graph; };
if ($EVAL_ERROR) {
  my $msg = 'Graph required to check graph based functionality';
  plan(skip_all => $msg);
}
else {
  plan tests => 14;
}

getGraphJoinSQL();

sub getGraphJoinSQL {
  my ($getGraphJoinSQLParams) = @_;
  my $subName = (caller(0))[3];

  # Let's create some testing DDL and make sure it gets translated as we expect
  my $s_sl_fk = q{ALTER TABLE JJJ.STORES
    ADD CONSTRAINT S_SL_FK FOREIGN KEY ( LOCATION_ID )
      REFERENCES JJJ.STORE_LOCATIONS ( LOCATION_ID );

      ALTER TABLE JJJ.LOCATION_PREF_SMELL
    ADD CONSTRAINT S_LPS_FK FOREIGN KEY ( SMELL_ID )
      REFERENCES JJJ.STORE_LOCATIONS ( SMELL_ID );
      };

  my $stores_locations_pk
    = qq{ALTER TABLE JJJ.STORE_LOCATIONS ADD CONSTRAINT STORES_LOCATIONS_PK PRIMARY KEY ( LOCATION_ID );};

  # Parse DDL Source file into usable components
  my ($pk_01, $fk_01) = JoinHero::getKeyComponents("$s_sl_fk \n $stores_locations_pk");

  my $g = getGraph({fkComponents => $fk_01});

  my $getGraphJoinSQLParamsStar = {fkComponents => $fk_01, graphTypes => ['JJJ:STAR->JJJ.STORES']};

  my $outputGraphJoinSQL = JoinHero::getGraphJoinSQL($getGraphJoinSQLParamsStar);

  my $expectedGraphJoinSQLStarStores = qq{
      MERGE INTO MART_TABLE_JOIN A USING
      (
      WITH C AS
        ( SELECT COUNT (*) AS rec_count
          FROM MART_TABLE_JOIN A
          WHERE
            A.TYPE = 'JJJ' AND
            NVL(A.CORE_FLG,'NULL') = 'Y' AND
            A.FROM_SCHEMA = 'JJJ' AND
            A.TO_SCHEMA = 'JJJ' AND
            A.FROM_TABLE = 'STORES' AND
            A.TO_TABLE = 'STORE_LOCATIONS'
        )
      SELECT mtj.*
      FROM  (
        SELECT
          'JJJ' as FROM_SCHEMA,
          'STORES' as FROM_TABLE,
          'LOCATION_ID' as FROM_FIELD,
          'JJJ' as TO_SCHEMA,
          'STORE_LOCATIONS' as TO_TABLE,
          'LOCATION_ID' as TO_FIELD,
          1 as FIELD_JOIN_ORD,
          'JJJ' as TYPE,
          'AUTO-GENERATED BY JoinHero Version: $JoinHero::VERSION using S_SL_FK via transform JJJ:STAR->JJJ.STORES at a depth of 1' as NOTES,
          'Y' as CORE_FLG
        FROM DUAL
      ) mtj
        CROSS JOIN c
        WHERE c.rec_count = 0
      ) B
      ON (  A.TYPE = B.TYPE
        and NVL(A.CORE_FLG,'NULL1') = NVL(B.CORE_FLG,'NULL2')
        and A.FROM_SCHEMA = B.FROM_SCHEMA
        and A.TO_SCHEMA = B.TO_SCHEMA
        and A.FROM_TABLE = B.FROM_TABLE
        and A.TO_TABLE = B.TO_TABLE
        and A.FIELD_JOIN_ORD = B.FIELD_JOIN_ORD)
      WHEN NOT MATCHED THEN
      INSERT (
        FROM_SCHEMA, FROM_TABLE, FROM_FIELD, TO_SCHEMA, TO_TABLE,
        TO_FIELD, FIELD_JOIN_ORD, TYPE, NOTES, CORE_FLG)
      VALUES (
        B.FROM_SCHEMA, B.FROM_TABLE, B.FROM_FIELD, B.TO_SCHEMA, B.TO_TABLE,
        B.TO_FIELD, B.FIELD_JOIN_ORD, B.TYPE, B.NOTES, B.CORE_FLG);

      MERGE INTO MART_TABLE_JOIN_CARDINALITY A USING
      (
        SELECT
          'JJJ' as FROM_SCHEMA,
          'STORES' as FROM_TABLE,
          'JJJ' as TO_SCHEMA,
          'STORE_LOCATIONS' as TO_TABLE,
          'ONE' as CARDINALITY,
          'JJJ' as TYPE,
          'AUTO-GENERATED BY JoinHero Version: $JoinHero::VERSION using S_SL_FK via transform JJJ:STAR->JJJ.STORES at a depth of 1' as NOTES,
          'Y' as CORE_FLG
        FROM DUAL
      ) B
      ON (
        A.TYPE = B.TYPE
        and NVL(A.CORE_FLG,'NULL1') = NVL(B.CORE_FLG,'NULL2')
        and A.FROM_SCHEMA = B.FROM_SCHEMA
        and A.TO_SCHEMA = B.TO_SCHEMA
        and A.FROM_TABLE = B.FROM_TABLE
        and A.TO_TABLE = B.TO_TABLE)
      WHEN NOT MATCHED THEN
      INSERT (
        FROM_SCHEMA, FROM_TABLE, TO_SCHEMA, TO_TABLE, CARDINALITY,
        TYPE, NOTES, CORE_FLG)
      VALUES (
        B.FROM_SCHEMA, B.FROM_TABLE, B.TO_SCHEMA, B.TO_TABLE, B.CARDINALITY,
        B.TYPE, B.NOTES, B.CORE_FLG);
  };

  ok(whitespaceInsensitiveCompare($expectedGraphJoinSQLStarStores, $outputGraphJoinSQL),
     "$subName expectedGraphJoinSQLStarStores output matches expected value");

  # And the snowflake version should have the additional jumps in the sql output
  my $expectedGraphJoinSQLSnowflakeStores .= qq{
    MERGE INTO MART_TABLE_JOIN A USING
      (
      WITH C AS
        ( SELECT COUNT (*) AS rec_count
          FROM MART_TABLE_JOIN A
          WHERE
            A.TYPE = 'JJJ' AND
            NVL(A.CORE_FLG,'NULL') = 'Y' AND
            A.FROM_SCHEMA = 'JJJ' AND
            A.TO_SCHEMA = 'JJJ' AND
            A.FROM_TABLE = 'STORES' AND
            A.TO_TABLE = 'STORE_LOCATIONS'
        )
      SELECT mtj.*
      FROM  (
        SELECT
          'JJJ' as FROM_SCHEMA,
          'STORES' as FROM_TABLE,
          'LOCATION_ID' as FROM_FIELD,
          'JJJ' as TO_SCHEMA,
          'STORE_LOCATIONS' as TO_TABLE,
          'LOCATION_ID' as TO_FIELD,
          1 as FIELD_JOIN_ORD,
          'JJJ' as TYPE,
          'AUTO-GENERATED BY JoinHero Version: $JoinHero::VERSION using S_SL_FK via transform JJJ:SNOWFLAKE->JJJ.STORES at a depth of 1' as NOTES,
          'Y' as CORE_FLG
        FROM DUAL
      ) mtj
        CROSS JOIN c
        WHERE c.rec_count = 0
      ) B
      ON (  A.TYPE = B.TYPE
        and NVL(A.CORE_FLG,'NULL1') = NVL(B.CORE_FLG,'NULL2')
        and A.FROM_SCHEMA = B.FROM_SCHEMA
        and A.TO_SCHEMA = B.TO_SCHEMA
        and A.FROM_TABLE = B.FROM_TABLE
        and A.TO_TABLE = B.TO_TABLE
        and A.FIELD_JOIN_ORD = B.FIELD_JOIN_ORD)
      WHEN NOT MATCHED THEN
      INSERT (
        FROM_SCHEMA, FROM_TABLE, FROM_FIELD, TO_SCHEMA, TO_TABLE,
        TO_FIELD, FIELD_JOIN_ORD, TYPE, NOTES, CORE_FLG)
      VALUES (
        B.FROM_SCHEMA, B.FROM_TABLE, B.FROM_FIELD, B.TO_SCHEMA, B.TO_TABLE,
        B.TO_FIELD, B.FIELD_JOIN_ORD, B.TYPE, B.NOTES, B.CORE_FLG);

      MERGE INTO MART_TABLE_JOIN_CARDINALITY A USING
      (
        SELECT
          'JJJ' as FROM_SCHEMA,
          'STORES' as FROM_TABLE,
          'JJJ' as TO_SCHEMA,
          'STORE_LOCATIONS' as TO_TABLE,
          'ONE' as CARDINALITY,
          'JJJ' as TYPE,
          'AUTO-GENERATED BY JoinHero Version: $JoinHero::VERSION using S_SL_FK via transform JJJ:SNOWFLAKE->JJJ.STORES at a depth of 1' as NOTES,
          'Y' as CORE_FLG
        FROM DUAL
      ) B
      ON (
        A.TYPE = B.TYPE
        and NVL(A.CORE_FLG,'NULL1') = NVL(B.CORE_FLG,'NULL2')
        and A.FROM_SCHEMA = B.FROM_SCHEMA
        and A.TO_SCHEMA = B.TO_SCHEMA
        and A.FROM_TABLE = B.FROM_TABLE
        and A.TO_TABLE = B.TO_TABLE)
      WHEN NOT MATCHED THEN
      INSERT (
        FROM_SCHEMA, FROM_TABLE, TO_SCHEMA, TO_TABLE, CARDINALITY,
        TYPE, NOTES, CORE_FLG)
      VALUES (
        B.FROM_SCHEMA, B.FROM_TABLE, B.TO_SCHEMA, B.TO_TABLE, B.CARDINALITY,
        B.TYPE, B.NOTES, B.CORE_FLG);

      MERGE INTO MART_TABLE_JOIN A USING
      (
      WITH C AS
        ( SELECT COUNT (*) AS rec_count
          FROM MART_TABLE_JOIN A
          WHERE
            A.TYPE = 'JJJ' AND
            NVL(A.CORE_FLG,'NULL') = 'Y' AND
            A.FROM_SCHEMA = 'JJJ' AND
            A.TO_SCHEMA = 'JJJ' AND
            A.FROM_TABLE = 'STORE_LOCATIONS' AND
            A.TO_TABLE = 'LOCATION_PREF_SMELL'
        )
      SELECT mtj.*
      FROM  (
        SELECT
          'JJJ' as FROM_SCHEMA,
          'STORE_LOCATIONS' as FROM_TABLE,
          'SMELL_ID' as FROM_FIELD,
          'JJJ' as TO_SCHEMA,
          'LOCATION_PREF_SMELL' as TO_TABLE,
          'SMELL_ID' as TO_FIELD,
          1 as FIELD_JOIN_ORD,
          'JJJ' as TYPE,
          'AUTO-GENERATED BY JoinHero Version: $JoinHero::VERSION using S_LPS_FK in REVERSED mode via transform JJJ:SNOWFLAKE->JJJ.STORES at a depth of 2' as NOTES,
          'Y' as CORE_FLG
        FROM DUAL
      ) mtj
        CROSS JOIN c
        WHERE c.rec_count = 0
      ) B
      ON (  A.TYPE = B.TYPE
        and NVL(A.CORE_FLG,'NULL1') = NVL(B.CORE_FLG,'NULL2')
        and A.FROM_SCHEMA = B.FROM_SCHEMA
        and A.TO_SCHEMA = B.TO_SCHEMA
        and A.FROM_TABLE = B.FROM_TABLE
        and A.TO_TABLE = B.TO_TABLE
        and A.FIELD_JOIN_ORD = B.FIELD_JOIN_ORD)
      WHEN NOT MATCHED THEN
      INSERT (
        FROM_SCHEMA, FROM_TABLE, FROM_FIELD, TO_SCHEMA, TO_TABLE,
        TO_FIELD, FIELD_JOIN_ORD, TYPE, NOTES, CORE_FLG)
      VALUES (
        B.FROM_SCHEMA, B.FROM_TABLE, B.FROM_FIELD, B.TO_SCHEMA, B.TO_TABLE,
        B.TO_FIELD, B.FIELD_JOIN_ORD, B.TYPE, B.NOTES, B.CORE_FLG);

      MERGE INTO MART_TABLE_JOIN_CARDINALITY A USING
      (
        SELECT
          'JJJ' as FROM_SCHEMA,
          'STORE_LOCATIONS' as FROM_TABLE,
          'JJJ' as TO_SCHEMA,
          'LOCATION_PREF_SMELL' as TO_TABLE,
          'MANY' as CARDINALITY,
          'JJJ' as TYPE,
          'AUTO-GENERATED BY JoinHero Version: $JoinHero::VERSION using S_LPS_FK in REVERSED mode via transform JJJ:SNOWFLAKE->JJJ.STORES at a depth of 2' as NOTES,
          'Y' as CORE_FLG
        FROM DUAL
      ) B
      ON (
        A.TYPE = B.TYPE
        and NVL(A.CORE_FLG,'NULL1') = NVL(B.CORE_FLG,'NULL2')
        and A.FROM_SCHEMA = B.FROM_SCHEMA
        and A.TO_SCHEMA = B.TO_SCHEMA
        and A.FROM_TABLE = B.FROM_TABLE
        and A.TO_TABLE = B.TO_TABLE)
      WHEN NOT MATCHED THEN
      INSERT (
        FROM_SCHEMA, FROM_TABLE, TO_SCHEMA, TO_TABLE, CARDINALITY,
        TYPE, NOTES, CORE_FLG)
      VALUES (
        B.FROM_SCHEMA, B.FROM_TABLE, B.TO_SCHEMA, B.TO_TABLE, B.CARDINALITY,
        B.TYPE, B.NOTES, B.CORE_FLG);
  };

  my $getGraphJoinSQLParamsSnowflake    = {fkComponents => $fk_01, graphTypes => ['JJJ:SNOWFLAKE->JJJ.STORES']};
  my $outputGraphJoinSQLSnowflakeStores = JoinHero::getGraphJoinSQL($getGraphJoinSQLParamsSnowflake);
  ok(whitespaceInsensitiveCompare($expectedGraphJoinSQLSnowflakeStores, $outputGraphJoinSQLSnowflakeStores),
     "$subName outputGraphJoinSQLSnowflakeStores output matches expected value");

  return;
} ## end sub getGraphJoinSQL

sub getGraph {
  my ($getGraphParams) = @_;
  my $subName = (caller(0))[3];

  # Build graph from fkComponents
  my $g = JoinHero::getGraph($getGraphParams);

  # Check edges
  my @ue = $g->unique_edges;
  $JoinHero::logger->info("$subName \@ue: " . JoinHero::Dumper(@ue));
  my $expectedEdge1 = ['JJJ.STORE_LOCATIONS',     'JJJ.STORES'];
  my $expectedEdge2 = ['JJJ.STORES',              'JJJ.STORE_LOCATIONS'];
  my $expectedEdge3 = ['JJJ.LOCATION_PREF_SMELL', 'JJJ.STORE_LOCATIONS'];
  my $expectedEdge4 = ['JJJ.STORE_LOCATIONS',     'JJJ.LOCATION_PREF_SMELL'];

  my $edge1Match = 0;
  my $edge2Match = 0;
  my $edge3Match = 0;
  my $edge4Match = 0;
  for my $edge (@ue) {
    if (@$edge ~~ $expectedEdge1) { $edge1Match = 1 }
    if (@$edge ~~ $expectedEdge2) { $edge2Match = 1 }
    if (@$edge ~~ $expectedEdge3) { $edge3Match = 1 }
    if (@$edge ~~ $expectedEdge4) { $edge4Match = 1 }
  } ## end for my $edge (@ue)
  ok($edge1Match == 1, "$subName Expected edge 1 found");
  ok($edge2Match == 1, "$subName Expected edge 2 found");
  ok($edge3Match == 1, "$subName Expected edge 3 found");
  ok($edge4Match == 1, "$subName Expected edge 4 found");

  # Check vertices
  my @uv = $g->unique_vertices;
  $JoinHero::logger->info("$subName \@uv: " . JoinHero::Dumper(@uv));
  my $expectedVertex1 = 'JJJ.STORE_LOCATIONS';
  my $expectedVertex2 = 'JJJ.STORES';
  ok($expectedVertex1 ~~ @uv, "$subName Expected vertex 1 found");
  ok($expectedVertex2 ~~ @uv, "$subName Expected vertex 2 found");

  # Check edge weights
  my $ew1to2 = $g->get_edge_weight($expectedVertex1, $expectedVertex2);
  $JoinHero::logger->info("$subName \$ew1to2: " . JoinHero::Dumper($ew1to2));
  my $ew2to1 = $g->get_edge_weight($expectedVertex2, $expectedVertex1);
  $JoinHero::logger->info("$subName \$ew2to1: " . JoinHero::Dumper($ew2to1));
  ok($ew1to2 == 1,  "$subName Expected weight for 'ONE' cardinality join found");
  ok($ew2to1 == 10, "$subName Expected weight for 'MANY' cardinality join found");

  # Check attributes
  my $ea1to2 = $g->get_edge_attributes($expectedVertex1, $expectedVertex2);
  $JoinHero::logger->info("$subName \$ea1to2: " . JoinHero::Dumper($ea1to2));
  ok($ea1to2->{fkKey} eq 'S_SL_FK-_-JJJ.STORES-_-JJJ.STORE_LOCATIONS',
     "$subName ea1to2 fkKey attribute matches expected value");
  ok($ea1to2->{direction} eq 'NORMAL', "$subName ea1to2 direction attribute matches expected value");
  my $ea2to1 = $g->get_edge_attributes($expectedVertex2, $expectedVertex1);
  $JoinHero::logger->info("$subName \$ea2to1: " . JoinHero::Dumper($ea2to1));
  ok($ea2to1->{fkKey} eq 'S_SL_FK-_-JJJ.STORES-_-JJJ.STORE_LOCATIONS',
     "$subName ea2to1 fkKey attribute matches expected value");
  ok($ea2to1->{direction} eq 'REVERSED', "$subName ea2to1 direction attribute matches expected value");

  return $g;
} ## end sub getGraph

sub whitespaceInsensitiveCompare {
  my ($string1, $string2) = @_;

  my $temp1 = $string1;
  $temp1 =~ s/\s+//g;
  my $temp2 = $string2;
  $temp2 =~ s/\s+//g;

  my $compare = 0;
  if ($temp1 eq $temp2) { $compare = 1; }

  return $compare;
} ## end sub whitespaceInsensitiveCompare
