#!/usr/bin/perl -w
use strict;
use warnings FATAL => 'all';
use Test::More;
use English qw(-no_match_vars);
no if $] >= 5.017011, warnings => 'experimental::smartmatch';    # Suppress smartmatch warnings

use JoinHero;

# $JoinHero::verbose = 1;    # Uncomment this and run tests with --verbose to ease debugging

# Skip these tests if we don't have the graph library
eval { require Graph; };
if ($EVAL_ERROR) {
  my $msg = 'Graph required to check graph based functionality';
  plan(skip_all => $msg);
}
else {
  plan tests => 11;
}

getGraphJoinSQL();

sub getGraphJoinSQL {
  my ($getGraphJoinSQLParams) = @_;
  my $subName = (caller(0))[3];

  # Let's create some testing DDL and make sure it gets translated as we expect
  my $s_sl_fk = q{ALTER TABLE JJJ.STORES
    ADD CONSTRAINT S_SL_FK FOREIGN KEY ( LOCATION_ID )
      REFERENCES JJJ.STORE_LOCATIONS ( LOCATION_ID );};

  my $stores_locations_pk
    = qq{ALTER TABLE JJJ.STORE_LOCATIONS ADD CONSTRAINT STORES_LOCATIONS_PK PRIMARY KEY ( LOCATION_ID );};

  # Parse DDL Source file into usable components
  my ($pk_01, $fk_01) = JoinHero::getKeyComponents("$s_sl_fk \n $stores_locations_pk");

  my $g = getGraph({fkComponents => $fk_01});

  my $getGraphJoinSQLParamsJH = {fkComponents => $fk_01, graphTypes => ['JJJ_STAR_TEST:STAR->STORES']};

  my $outputGraphJoinSQL = JoinHero::getGraphJoinSQL($getGraphJoinSQLParamsJH);

  my $expectedGraphJoinSQL = qq{
      MERGE INTO MART_TABLE_JOIN A USING
      (
      WITH C AS
        ( SELECT COUNT (*) AS rec_count
          FROM MART_TABLE_JOIN A
          WHERE
            A.TYPE = 'JJJ_STAR_TEST' AND
            NVL(A.CORE_FLG,'NULL') = 'Y' AND
            A.FROM_SCHEMA = 'JJJ' AND
            A.TO_SCHEMA = 'JJJ' AND
            A.FROM_TABLE = 'STORES' AND
            A.TO_TABLE = 'STORE_LOCATIONS'
        )
      SELECT mtj.*
      FROM  (
        SELECT
          'JJJ' as FROM_SCHEMA,
          'STORES' as FROM_TABLE,
          'LOCATION_ID' as FROM_FIELD,
          'JJJ' as TO_SCHEMA,
          'STORE_LOCATIONS' as TO_TABLE,
          'LOCATION_ID' as TO_FIELD,
          1 as FIELD_JOIN_ORD,
          'JJJ_STAR_TEST' as TYPE,
          'AUTO-GENERATED BY JoinHero Version: $JoinHero::VERSION using S_SL_FK' as NOTES,
          'Y' as CORE_FLG
        FROM DUAL
      ) mtj
        CROSS JOIN c
        WHERE c.rec_count = 0
      ) B
      ON (  A.TYPE = B.TYPE
        and NVL(A.CORE_FLG,'NULL1') = NVL(B.CORE_FLG,'NULL2')
        and A.FROM_SCHEMA = B.FROM_SCHEMA
        and A.TO_SCHEMA = B.TO_SCHEMA
        and A.FROM_TABLE = B.FROM_TABLE
        and A.TO_TABLE = B.TO_TABLE
        and A.FIELD_JOIN_ORD = B.FIELD_JOIN_ORD)
      WHEN NOT MATCHED THEN
      INSERT (
        FROM_SCHEMA, FROM_TABLE, FROM_FIELD, TO_SCHEMA, TO_TABLE,
        TO_FIELD, FIELD_JOIN_ORD, TYPE, NOTES, CORE_FLG)
      VALUES (
        B.FROM_SCHEMA, B.FROM_TABLE, B.FROM_FIELD, B.TO_SCHEMA, B.TO_TABLE,
        B.TO_FIELD, B.FIELD_JOIN_ORD, B.TYPE, B.NOTES, B.CORE_FLG);

      MERGE INTO MART_TABLE_JOIN_CARDINALITY A USING
      (
        SELECT
          'JJJ' as FROM_SCHEMA,
          'STORES' as FROM_TABLE,
          'JJJ' as TO_SCHEMA,
          'STORE_LOCATIONS' as TO_TABLE,
          'ONE' as CARDINALITY,
          'JJJ_STAR_TEST' as TYPE,
          'AUTO-GENERATED BY JoinHero Version: $JoinHero::VERSION using S_SL_FK' as NOTES,
          'Y' as CORE_FLG
        FROM DUAL
      ) B
      ON (
        A.TYPE = B.TYPE
        and NVL(A.CORE_FLG,'NULL1') = NVL(B.CORE_FLG,'NULL2')
        and A.FROM_SCHEMA = B.FROM_SCHEMA
        and A.TO_SCHEMA = B.TO_SCHEMA
        and A.FROM_TABLE = B.FROM_TABLE
        and A.TO_TABLE = B.TO_TABLE)
      WHEN NOT MATCHED THEN
      INSERT (
        FROM_SCHEMA, FROM_TABLE, TO_SCHEMA, TO_TABLE, CARDINALITY,
        TYPE, NOTES, CORE_FLG)
      VALUES (
        B.FROM_SCHEMA, B.FROM_TABLE, B.TO_SCHEMA, B.TO_TABLE, B.CARDINALITY,
        B.TYPE, B.NOTES, B.CORE_FLG);
  };

  ok(whitespaceInsensitiveCompare($expectedGraphJoinSQL, $outputGraphJoinSQL),
     "$subName getGraphJoinSQL output matches expected value");

  return;
} ## end sub getGraphJoinSQL

sub getGraph {
  my ($getGraphParams) = @_;
  my $subName = (caller(0))[3];

  # Build graph from fkComponents
  my $g = JoinHero::getGraph($getGraphParams);

  # Check edges
  my @ue = $g->unique_edges;
  $JoinHero::logger->info("$subName \@ue: " . JoinHero::Dumper(@ue));
  my $expectedEdge1 = ['STORE_LOCATIONS', 'STORES'];
  my $expectedEdge2 = ['STORES',          'STORE_LOCATIONS'];
  ok($expectedEdge1 ~~ @ue, "$subName Expected edge 1 found");
  ok($expectedEdge2 ~~ @ue, "$subName Expected edge 2 found");

  # Check vertices
  my @uv = $g->unique_vertices;
  $JoinHero::logger->info("$subName \@uv: " . JoinHero::Dumper(@uv));
  my $expectedVertex1 = 'STORE_LOCATIONS';
  my $expectedVertex2 = 'STORES';
  ok($expectedVertex1 ~~ @uv, "$subName Expected vertex 1 found");
  ok($expectedVertex2 ~~ @uv, "$subName Expected vertex 2 found");

  # Check edge weights
  my $ew1to2 = $g->get_edge_weight($expectedVertex1, $expectedVertex2);
  $JoinHero::logger->info("$subName \$ew1to2: " . JoinHero::Dumper($ew1to2));
  my $ew2to1 = $g->get_edge_weight($expectedVertex2, $expectedVertex1);
  $JoinHero::logger->info("$subName \$ew2to1: " . JoinHero::Dumper($ew2to1));
  ok($ew1to2 == 1,  "$subName Expected weight for 'ONE' cardinality join found");
  ok($ew2to1 == 10, "$subName Expected weight for 'MANY' cardinality join found");

  # Check attributes
  my $ea1to2 = $g->get_edge_attributes($expectedVertex1, $expectedVertex2);
  $JoinHero::logger->info("$subName \$ea1to2: " . JoinHero::Dumper($ea1to2));
  ok($ea1to2->{fkKey} eq 'S_SL_FK-_-JJJ.STORES-_-JJJ.STORE_LOCATIONS',
     "$subName ea1to2 fkKey attribute matches expected value");
  ok($ea1to2->{direction} eq 'NORMAL', "$subName ea1to2 direction attribute matches expected value");
  my $ea2to1 = $g->get_edge_attributes($expectedVertex2, $expectedVertex1);
  $JoinHero::logger->info("$subName \$ea2to1: " . JoinHero::Dumper($ea2to1));
  ok($ea2to1->{fkKey} eq 'S_SL_FK-_-JJJ.STORES-_-JJJ.STORE_LOCATIONS',
     "$subName ea2to1 fkKey attribute matches expected value");
  ok($ea2to1->{direction} eq 'REVERSED', "$subName ea2to1 direction attribute matches expected value");

  return $g;
} ## end sub getGraph

sub whitespaceInsensitiveCompare {
  my ($string1, $string2) = @_;

  my $temp1 = $string1;
  $temp1 =~ s/\s+//g;
  my $temp2 = $string2;
  $temp2 =~ s/\s+//g;

  my $compare = 0;
  if ($temp1 eq $temp2) { $compare = 1; }

  return $compare;
} ## end sub whitespaceInsensitiveCompare
